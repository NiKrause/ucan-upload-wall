# [Enhancement] Implement WebAuthn Ed25519 varsig for hardware-backed UCAN signing

## Summary

Replace the current software-based Ed25519 keystore (worker-based) with **hardware-backed WebAuthn Ed25519 signatures** using varsig format. This can be implemented entirely within our project without forking ucanto/core.

## Current Architecture (Vulnerable)

```
WebAuthn P-256 → PRF Seed → AES Key → Ed25519 in Worker → Sign in JS
     ↑                                        ↑
  Hardware                              Software (Extractable)
```

**Problems:**
- ❌ Ed25519 keys exist in worker memory (extractable via XSS)
- ❌ Encrypted archive in localStorage vulnerable
- ❌ Single biometric auth, not per-operation
- ❌ See [SECURITY.md](SECURITY.md) for full analysis

## Proposed Architecture (Hardware-Backed)

```
WebAuthn Ed25519 → Sign UCAN with varsig → Custom verification layer → ucanto
     ↑                                              ↑
  Hardware (Secure)                        Our code validates WebAuthn
```

**Benefits:**
- ✅ Ed25519 keys **never leave hardware** (TPM/Secure Enclave)
- ✅ **Biometric per signing operation** (not just unlock)
- ✅ Impossible to extract keys (even with XSS)
- ✅ No localStorage vulnerability
- ✅ No ucanto/Storacha changes needed initially

## Implementation Approach

### Key Insight: Custom Verification Layer

We handle WebAuthn verification ourselves, then pass to ucanto:

```typescript
// web/src/lib/webauthn-ucan-signer.ts (NEW)
async function signUcanWithWebAuthn(payload, credential) {
  // 1. Sign with WebAuthn Ed25519 (hardware)
  const assertion = await navigator.credentials.get({
    publicKey: { challenge: sha256(payload) }
  });
  
  // 2. Package as varsig
  return encodeWebAuthnEd25519Varsig({
    authenticatorData: assertion.response.authenticatorData,
    clientDataJSON: assertion.response.clientDataJSON,
    signature: assertion.response.signature
  });
}

// web/src/lib/webauthn-ucan-verifier.ts (NEW)
async function verifyWebAuthnUcan(varsigUcan) {
  // 1. Decode varsig
  const { authenticatorData, clientDataJSON, signature } = decode(varsigUcan);
  
  // 2. Verify WebAuthn assertion (our code)
  await verifyWebAuthnEd25519(authenticatorData, clientDataJSON, signature);
  
  // 3. Pass to ucanto (no changes needed to ucanto!)
  const { extract } = await import('@ucanto/core/delegation');
  return await extract(extractPayload(varsigUcan));
}
```

### Varsig Format

```
varsig = [0x2ed1] + [authData_len] + [authData] + [clientData_len] + [clientData] + [sig_64bytes]
         ↑ multicodec for WebAuthn Ed25519
```

## Implementation Plan

### Phase 1: Core Implementation (4-6 weeks)
- [ ] Create `web/src/lib/webauthn-varsig/` module
  - [ ] `encoder.ts` - Encode WebAuthn assertions as varsig
  - [ ] `decoder.ts` - Decode varsig to WebAuthn data
  - [ ] `verifier.ts` - Verify WebAuthn Ed25519 signatures
  - [ ] `signer.ts` - Sign UCANs with WebAuthn
- [ ] Define multicodec: `0x2ed1` for WebAuthn Ed25519
- [ ] Implement varint encoding/decoding for length prefixes
- [ ] Add WebAuthn Ed25519 credential creation flow
- [ ] Update `UCANDelegationService` to support WebAuthn signing
- [ ] Add tests for varsig encode/decode
- [ ] Add tests for WebAuthn signature verification

### Phase 2: Integration (2-3 weeks)
- [ ] Update `createDelegation()` to use WebAuthn signing
- [ ] Update `importDelegation()` to verify WebAuthn varsig
- [ ] Add feature detection (fallback to worker if unsupported)
- [ ] Browser compatibility handling (Chrome 108+, Safari 17+)
- [ ] Migration path for existing users
- [ ] E2E tests with real WebAuthn credentials

### Phase 3: P-256 Support (2-3 weeks)
- [ ] Add multicodec `0x2256` for WebAuthn P-256
- [ ] Extend varsig encoder/decoder for P-256
- [ ] Add P-256 signature verification (ECDSA/SHA-256)
- [ ] Support both Ed25519 and P-256 credentials
- [ ] Leverage existing P-256 fork work if applicable
- [ ] Tests for P-256 variant

### Phase 4: Polish & Documentation (1-2 weeks)
- [ ] Update architecture docs
- [ ] Add WebAuthn setup guide
- [ ] Performance benchmarking
- [ ] Security audit of implementation
- [ ] Prepare demo for UCAN working group

## File Structure

```
web/src/lib/webauthn-varsig/
├── index.ts              # Public API
├── types.ts              # TypeScript types
├── multicodec.ts         # Multicodec constants
├── encoder.ts            # Varsig encoding
├── decoder.ts            # Varsig decoding
├── signer.ts             # WebAuthn signing
├── verifier.ts           # WebAuthn verification
└── utils.ts              # Varint, byte utilities

web/tests/
└── webauthn-varsig.spec.ts  # Unit + E2E tests
```

## Browser Support

| Browser | WebAuthn Ed25519 | Status |
|---------|------------------|--------|
| Chrome/Edge 108+ | ✅ | Fully supported |
| Safari 17+ (macOS 14+/iOS 17+) | ✅ | Fully supported |
| Firefox | ⚠️ | Platform dependent |

**Fallback:** Keep worker-based Ed25519 for unsupported browsers.

## Security Impact

| Attack Vector | Current (Worker) | WebAuthn Varsig |
|--------------|------------------|-----------------|
| XSS key extraction | ❌ Vulnerable | ✅ Impossible |
| localStorage attack | ❌ Vulnerable | ✅ No keys stored |
| Memory dumping | ❌ Vulnerable | ✅ Protected |
| Per-op authentication | ❌ No | ✅ Yes (biometric) |

## Ecosystem Integration

**Now:** Works entirely in our project  
**Later:** Propose to ucanto/Storacha with working implementation

**For Storacha API:** Run verification proxy if needed:
```
App → WebAuthn UCAN → Our Verifier → Standard UCAN → Storacha
```

## References

- [SECURITY.md](SECURITY.md) - Current vulnerabilities
- [WebAuthn Level 3](https://www.w3.org/TR/webauthn-3/)
- [Varsig Spec](https://github.com/multiformats/multicodec)
- Existing P-256 work: [NiKrause/ucanto](https://github.com/NiKrause/ucanto/tree/p256)

---

**Priority:** High  
**Complexity:** Medium  
**Impact:** Eliminates major security vulnerabilities  
**Dependencies:** None (self-contained implementation)
